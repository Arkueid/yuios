# 硬盘读写

- PIO: Port Input Output
- 端口是外部设备内部的寄存器

## 硬盘读写

- CHS 模式 / Cylinder / Head / Sector
- LBA 模式 / Logic Block Address

LBA28: 28位空间，共 2^28*512B = 128G 

主要思路：
- 将控制信号传输到磁盘控制器的端口上（寄存器）
- 等待磁盘响应
- 响应后读取端口数据到CPU中的寄存器
- 将读取的值存入内存

```s
[org 0x7c00]

; 设置屏幕模式为文本模式，清除屏幕
mov ax, 3
int 0x10

; 初始化段寄存器
mov ax, 0
mov ds, ax
mov es, ax
mov ss, ax
mov sp, 0x7c00

mov si, booting
call print

mov edi, 0x1000 ; 读取的目标内存
mov ecx, 0 ; 起始扇区
mov bl, 1 ; 扇区数量

call read_disk

; 阻塞
jmp $

read_disk:
    mov dx, 0x1f2
    mov al, bl
    out dx, al

    inc dx ; 0x1f3
    mov al, cl
    out dx, al

    inc dx ; 0x1f4
    shr ecx, 8
    mov al, cl
    out dx, al

    inc dx ; 0x1f5
    shr ecx, 8
    mov al, cl
    out dx, al

    inc dx ; 0x1f6
    shr ecx, 8
    and cl, 0b1111 ; 取低四位
    
    mov al, 0b1110_0000
    or al, cl
    out dx, al 

    inc dx ; 0x1f7
    mov al, 0x20
    out dx, al

    xor ecx, ecx ; 将ecx清空
    mov cl, bl ; 得到读写扇区的数量

    .read:
        push cx
        call .waits ; 等待扇区准备完毕
        call .reads ; 读取一个扇区
        pop cx
        loop .read
    ret

    .waits:
        mov dx, 0x1f7
        .check:
            in al, dx
            jmp $+2
            jmp $+2
            jmp $+2
            and al, 0b1000_1000
            cmp al, 0b0000_1000
            jnz .check
        ret

    .reads:
        mov dx, 0x1f0
        mov cx, 256
        .readw:
            in ax, dx
            jmp $+2
            jmp $+2
            jmp $+2
            mov [edi], ax
            add edi, 2
            loop .readw
        ret

        
print:
    mov ah, 0x0e
.next:
    mov al, [si]
    cmp al, 0
    jz .done
    int 0x10
    inc si
    jmp .next
.done
    ret

booting:
    db "Hello, world!", 10, 13, 0 ; \n \r 字符串结束符

times 510 - ($ - $$) db 0

; 主引导扇区的最后两个字节必须是 0x55 0xaa
db 0x55, 0xaa ; 小端储存
```